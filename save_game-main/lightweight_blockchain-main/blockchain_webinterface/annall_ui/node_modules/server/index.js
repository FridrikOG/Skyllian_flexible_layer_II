const test_data = require("./test_data");
const PayloadRepository = require("../payload_repository");
const WriterRepository = require("../writer_repository");
const BlockRepository = require("../block_repository");
const AppDAO = require("../dao");
const bodyParser = require("body-parser");
const express = require("express");
const path = require("path");
const cluster = require("cluster");
const numCPUs = require("os").cpus().length;

const isDev = process.env.NODE_ENV !== "production";
const PORT = process.env.PORT || 4000;
const keys = ["1"];
const adminKeys = ["1"];
const dao = new AppDAO("./database.sqlite3");
const payload_repo = new PayloadRepository(dao);
const writer_repo = new WriterRepository(dao);
const block_repo = new BlockRepository(dao);

function is_writer(json) {
  if (
    json.hasOwnProperty("ip") &&
    json.hasOwnProperty("port") &&
    json.hasOwnProperty("public_key") &&
    json.hasOwnProperty("ver_exp")
  ) {
    return true;
  } else {
    return false;
  }
}

function is_payload(json) {
  if (
    json.hasOwnProperty("name") &&
    json.hasOwnProperty("type") &&
    json.hasOwnProperty("data")
  ) {
    return true;
  } else {
    return false;
  }
}

function is_block(json) {
  if (
    json.hasOwnProperty("previous_hash") &&
    json.hasOwnProperty("writer_signature") &&
    json.hasOwnProperty("coordinator_id") &&
    json.hasOwnProperty("winner_number") &&
    json.hasOwnProperty("writer_id") &&
    json.hasOwnProperty("payload") &&
    is_payload(json.payload)
  ) {
    return true;
  } else {
    return false;
  }
}

// Multi-process to utilize all CPU cores.
if (!isDev && cluster.isMaster) {
  console.error(`Node cluster master ${process.pid} is running`);

  // Fork workers.
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }

  cluster.on("exit", (worker, code, signal) => {
    console.error(
      `Node cluster worker ${worker.process.pid} exited: code ${code}, signal ${signal}`
    );
  });
} else {
  const app = express();

  app.use(bodyParser.json()); // to support JSON-encoded bodies
  app.use(bodyParser.urlencoded());

  // Priority serve any static files.
  app.use(express.static(path.resolve(__dirname, "../react-ui/build")));

  // Answer API requests.
  app.get("/api", function (req, res) {
    res.sendFile(path.resolve(__dirname, "./documentation", "index.html"));
  });

  //TODO
  // Get all payloads waiting to be added that align with query parameters
  app.get("/api/payloads", function (req, res) {
    if (keys.includes(req.query.key)) {
      payload_repo
        .getAll()
        .then((payloads) => {
          payloads.forEach((payload) => {
            payload.data = JSON.parse(payload.data);
          });
          res.set("Content-Type", "application/json");
          res.send(payloads);
        })
        .catch((err) => {
          console.log("Error: ");
          console.log(JSON.stringify(err));
          res.sendStatus(500);
        });
    } else {
      res.sendStatus(401);
    }
  });

  //TODO
  // Get blockchain based on query parameters
  app.get("/api/blocks", function (req, res) {
    if (keys.includes(req.query.key)) {
      block_repo
        .getAll()
        .then((blocks) => {
          blocks.forEach((block) => {
            block.payload = JSON.parse(block.payload);
          });
          res.set("Content-Type", "application/json");
          res.send(blocks);
        })
        .catch((err) => {
          console.log("Error: ");
          console.log(JSON.stringify(err));
          res.sendStatus(500);
        });
    } else {
      res.sendStatus(401);
    }
  });

  //TODO
  // Get the list of writers for target chain
  app.get("/api/writers", function (req, res) {
    if (keys.includes(req.query.key)) {
      writer_repo
        .getAll()
        .then((writers) => {
          res.set("Content-Type", "application/json");
          res.send(writers);
        })
        .catch((err) => {
          console.log("Error: ");
          console.log(JSON.stringify(err));
          res.sendStatus(500);
        });
    } else {
      res.sendStatus(401);
    }
  });

  //TODO
  // Submits a new payload to be added to blockchain
  app.post("/api/payloads", function (req, res) {
    if (keys.includes(req.query.key)) {
      if (is_payload(req.body)) {
        payload_repo
          .create(req.body.name, req.body.type, JSON.stringify(req.body.data))
          .then(() => {
            res.set("Content-Type", "application/json");
            res.status(201);
            res.send(req.body);
          })
          .catch((err) => {
            console.log("Error: ");
            console.log(JSON.stringify(err));
            res.sendStatus(500);
          });
      } else {
        res.status(422);
        res.send(`Expected body to to be in the form:
            {
              "name": "name",
              "type": "type",
              "data": {}
            }`);
      }
    } else {
      res.sendStatus(401);
    }
  });

  //TODO
  // Submits a new block to be added to blockchain
  app.post("/api/blocks", function (req, res) {
    if (keys.includes(req.query.key)) {
      if (is_block(req.body)) {
        block_repo
          .create(
            req.body.winner_number,
            req.body.previous_hash,
            req.body.writer_id,
            req.body.coordinator_id,
            JSON.stringify(req.body.payload)
          )
          .then(() => {
            res.set("Content-Type", "application/json");
            res.status(201);
            res.send(req.body);
          })
          .catch((err) => {
            console.log("Error: ");
            console.log(JSON.stringify(err));
            res.sendStatus(500);
          });
      } else {
        res.status(422);
        res.send(`Expected body to to be in the form:
            {
              "previous_hash": "string",
              "writer_signature": "string",
              "writer_id": 0,
              "coordinator_id": 0,
              "winner_number": 0,
              "payload": {
                "id": 0,
                "name": "string",
                "type": "string",
                "data": {}
              }
            }`);
      }
    } else {
      res.sendStatus(401);
    }
  });

  //TODO
  // Submits a new writer to be added to blockchain
  app.post("/api/writers", function (req, res) {
    if (adminKeys.includes(req.query.key)) {
      if (is_writer(req.body)) {
        writer_repo
          .create(
            req.body.ip,
            req.body.port,
            req.body.public_key,
            req.body.ver_exp
          )
          .then(() => {
            res.set("Content-Type", "application/json");
            res.status(201);
            res.send(req.body);
          })
          .catch((err) => {
            console.log("Error: ");
            console.log(JSON.stringify(err));
            res.sendStatus(500);
          });
      } else {
        res.status(422);
        res.send(`Expected body to to be in the form:
            {
              "key": "string",
              "ip": "string",
              "port": "string"
            }`);
      }
    } else {
      res.sendStatus(401);
    }
  });

  //TODO
  // deletes a payload from db that has been added to blockchain
  app.delete("/api/payloads", function (req, res) {
    if (keys.includes(req.query.key)) {
      if (req.query.payload_id) {
        payload_repo
          .delete(req.query.payload_id)
          .then(() => {
            res.set("Content-Type", "application/json");
            res.sendStatus(200);
          })
          .catch((err) => {
            console.log("Error: ");
            console.log(JSON.stringify(err));
            res.sendStatus(500);
          });
      } else {
        res.status(404);
        res.send("Payload with that id not found");
      }
    } else {
      res.sendStatus(401);
    }
  });

  //TODO
  // Deletes a writer with the given id
  app.delete("/api/writers", function (req, res) {
    if (keys.includes(req.query.key)) {
      if (req.query.writer_id) {
        writer_repo
          .delete(req.query.writer_id)
          .then(() => {
            res.set("Content-Type", "application/json");
            res.sendStatus(200);
          })
          .catch((err) => {
            console.log("Error: ");
            console.log(JSON.stringify(err));
            res.sendStatus(500);
          });
      } else {
        res.status(404);
        res.send("Writer with that id not found");
      }
    } else {
      res.sendStatus(401);
    }
  });

  // All remaining requests return the React app, so it can handle routing.
  app.get("*", function (request, response) {
    response.sendFile(
      path.resolve(__dirname, "../react-ui/build", "index.html")
    );
  });

  app.listen(PORT, function () {
    console.error(
      `Node ${
        isDev ? "dev server" : "cluster worker " + process.pid
      }: listening on port ${PORT}`
    );
  });
}
